#include <stdint.h>
#include "round.h"

#define ROL64(x,n) (((x) << (n)) | ((x) >> (64 - (n))))

// 矩阵 Rho 位移常量表
static const int RHO_OFFSETS[5][5] = {
    {  0, 36,  3, 41, 18},
    {  1, 44, 10, 45,  2},
    { 62,  6, 43, 15, 61},
    { 28, 55, 25, 21, 56},
    { 27, 20, 39,  8, 14}
};

uint64_t **sha3_round(uint64_t **A, uint64_t RC, int round)
{
    uint64_t C0, C1, C2, C3, C4;
    uint64_t D0, D1, D2, D3, D4;
    uint64_t B[5][5];
    uint64_t T[5][5];

    // Theta (完全展开)
    C0 = A[0][0] ^ A[0][1] ^ A[0][2] ^ A[0][3] ^ A[0][4];
    C1 = A[1][0] ^ A[1][1] ^ A[1][2] ^ A[1][3] ^ A[1][4];
    C2 = A[2][0] ^ A[2][1] ^ A[2][2] ^ A[2][3] ^ A[2][4];
    C3 = A[3][0] ^ A[3][1] ^ A[3][2] ^ A[3][3] ^ A[3][4];
    C4 = A[4][0] ^ A[4][1] ^ A[4][2] ^ A[4][3] ^ A[4][4];

    D0 = C4 ^ ROL64(C1, 1);
    D1 = C0 ^ ROL64(C2, 1);
    D2 = C1 ^ ROL64(C3, 1);
    D3 = C2 ^ ROL64(C4, 1);
    D4 = C3 ^ ROL64(C0, 1);

    // Apply D[x] to A[x][y]
    A[0][0] ^= D0; A[0][1] ^= D0; A[0][2] ^= D0; A[0][3] ^= D0; A[0][4] ^= D0;
    A[1][0] ^= D1; A[1][1] ^= D1; A[1][2] ^= D1; A[1][3] ^= D1; A[1][4] ^= D1;
    A[2][0] ^= D2; A[2][1] ^= D2; A[2][2] ^= D2; A[2][3] ^= D2; A[2][4] ^= D2;
    A[3][0] ^= D3; A[3][1] ^= D3; A[3][2] ^= D3; A[3][3] ^= D3; A[3][4] ^= D3;
    A[4][0] ^= D4; A[4][1] ^= D4; A[4][2] ^= D4; A[4][3] ^= D4; A[4][4] ^= D4;

    // Rho + Pi (完全展开)
    B[0][0] = ROL64(A[0][0], RHO_OFFSETS[0][0]);
    B[1][3] = ROL64(A[0][1], RHO_OFFSETS[0][1]);
    B[2][1] = ROL64(A[0][2], RHO_OFFSETS[0][2]);
    B[3][4] = ROL64(A[0][3], RHO_OFFSETS[0][3]);
    B[4][2] = ROL64(A[0][4], RHO_OFFSETS[0][4]);

    B[0][2] = ROL64(A[1][0], RHO_OFFSETS[1][0]);
    B[1][0] = ROL64(A[1][1], RHO_OFFSETS[1][1]);
    B[2][3] = ROL64(A[1][2], RHO_OFFSETS[1][2]);
    B[3][1] = ROL64(A[1][3], RHO_OFFSETS[1][3]);
    B[4][4] = ROL64(A[1][4], RHO_OFFSETS[1][4]);

    B[0][4] = ROL64(A[2][0], RHO_OFFSETS[2][0]);
    B[1][2] = ROL64(A[2][1], RHO_OFFSETS[2][1]);
    B[2][0] = ROL64(A[2][2], RHO_OFFSETS[2][2]);
    B[3][3] = ROL64(A[2][3], RHO_OFFSETS[2][3]);
    B[4][1] = ROL64(A[2][4], RHO_OFFSETS[2][4]);

    B[0][1] = ROL64(A[3][0], RHO_OFFSETS[3][0]);
    B[1][4] = ROL64(A[3][1], RHO_OFFSETS[3][1]);
    B[2][2] = ROL64(A[3][2], RHO_OFFSETS[3][2]);
    B[3][0] = ROL64(A[3][3], RHO_OFFSETS[3][3]);
    B[4][3] = ROL64(A[3][4], RHO_OFFSETS[3][4]);

    B[0][3] = ROL64(A[4][0], RHO_OFFSETS[4][0]);
    B[1][1] = ROL64(A[4][1], RHO_OFFSETS[4][1]);
    B[2][4] = ROL64(A[4][2], RHO_OFFSETS[4][2]);
    B[3][2] = ROL64(A[4][3], RHO_OFFSETS[4][3]);
    B[4][0] = ROL64(A[4][4], RHO_OFFSETS[4][4]);

    //Chi (完全展开)
    T[0][0] = B[0][0] ^ ((~B[1][0]) & B[2][0]);
    T[0][1] = B[0][1] ^ ((~B[1][1]) & B[2][1]);
    T[0][2] = B[0][2] ^ ((~B[1][2]) & B[2][2]);
    T[0][3] = B[0][3] ^ ((~B[1][3]) & B[2][3]);
    T[0][4] = B[0][4] ^ ((~B[1][4]) & B[2][4]);

    T[1][0] = B[1][0] ^ ((~B[2][0]) & B[3][0]);
    T[1][1] = B[1][1] ^ ((~B[2][1]) & B[3][1]);
    T[1][2] = B[1][2] ^ ((~B[2][2]) & B[3][2]);
    T[1][3] = B[1][3] ^ ((~B[2][3]) & B[3][3]);
    T[1][4] = B[1][4] ^ ((~B[2][4]) & B[3][4]);

    T[2][0] = B[2][0] ^ ((~B[3][0]) & B[4][0]);
    T[2][1] = B[2][1] ^ ((~B[3][1]) & B[4][1]);
    T[2][2] = B[2][2] ^ ((~B[3][2]) & B[4][2]);
    T[2][3] = B[2][3] ^ ((~B[3][3]) & B[4][3]);
    T[2][4] = B[2][4] ^ ((~B[3][4]) & B[4][4]);

    T[3][0] = B[3][0] ^ ((~B[4][0]) & B[0][0]);
    T[3][1] = B[3][1] ^ ((~B[4][1]) & B[0][1]);
    T[3][2] = B[3][2] ^ ((~B[4][2]) & B[0][2]);
    T[3][3] = B[3][3] ^ ((~B[4][3]) & B[0][3]);
    T[3][4] = B[3][4] ^ ((~B[4][4]) & B[0][4]);

    T[4][0] = B[4][0] ^ ((~B[0][0]) & B[1][0]);
    T[4][1] = B[4][1] ^ ((~B[0][1]) & B[1][1]);
    T[4][2] = B[4][2] ^ ((~B[0][2]) & B[1][2]);
    T[4][3] = B[4][3] ^ ((~B[0][3]) & B[1][3]);
    T[4][4] = B[4][4] ^ ((~B[0][4]) & B[1][4]);

    // 写回 A 并做 Iota
    A[0][0] = T[0][0]; A[0][1] = T[0][1]; A[0][2] = T[0][2]; A[0][3] = T[0][3]; A[0][4] = T[0][4];
    A[1][0] = T[1][0]; A[1][1] = T[1][1]; A[1][2] = T[1][2]; A[1][3] = T[1][3]; A[1][4] = T[1][4];
    A[2][0] = T[2][0]; A[2][1] = T[2][1]; A[2][2] = T[2][2]; A[2][3] = T[2][3]; A[2][4] = T[2][4];
    A[3][0] = T[3][0]; A[3][1] = T[3][1]; A[3][2] = T[3][2]; A[3][3] = T[3][3]; A[3][4] = T[3][4];
    A[4][0] = T[4][0]; A[4][1] = T[4][1]; A[4][2] = T[4][2]; A[4][3] = T[4][3]; A[4][4] = T[4][4];

    A[0][0] ^= RC;
    return A;
}
